package analyzer

import (
	"archive/zip"
	"crypto/sha1"
	"encoding/binary"
	"fmt"
	"hash/adler32"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/h0tak88r/apkX/internal/utils"
)

type JanusVulnerabilityAnalyzer struct {
	apkPath string
}

type JanusAPKInfo struct {
	HasV1Signature bool
	HasV2Signature bool
	HasV3Signature bool
	FilePath       string
	Vulnerability  string
	Severity       string
	Description    string
	Impact         string
	Recommendation string
}

func NewJanusVulnerabilityAnalyzer() *JanusVulnerabilityAnalyzer {
	return &JanusVulnerabilityAnalyzer{}
}

func (a *JanusVulnerabilityAnalyzer) SetAPKPath(apkPath string) {
	a.apkPath = apkPath
}

func (a *JanusVulnerabilityAnalyzer) Analyze(decompileDir string) ([]string, error) {
	// Use the stored APK path
	if a.apkPath == "" {
		return nil, fmt.Errorf("APK path not set")
	}

	// Analyze APK for Janus vulnerability
	info, err := a.analyzeAPK(a.apkPath)
	if err != nil {
		return nil, fmt.Errorf("failed to analyze APK: %v", err)
	}

	// Generate findings
	return a.generateFindings(info), nil
}

func (a *JanusVulnerabilityAnalyzer) findAPKFile(decompileDir string) (string, error) {
	// Look for APK files in common locations
	searchPaths := []string{
		decompileDir,
		filepath.Dir(decompileDir),
		filepath.Join(filepath.Dir(decompileDir), ".."),
	}

	var foundAPK string
	for _, searchPath := range searchPaths {
		err := filepath.Walk(searchPath, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.HasSuffix(strings.ToLower(path), ".apk") {
				foundAPK = path
				return filepath.SkipDir
			}
			return nil
		})
		if err != nil && err != filepath.SkipDir {
			continue
		}
		if foundAPK != "" {
			break
		}
	}

	// If no APK found in search paths, return error
	if foundAPK == "" {
		return "", fmt.Errorf("no APK file found in decompiled directory")
	}

	return foundAPK, nil
}

func (a *JanusVulnerabilityAnalyzer) analyzeAPK(apkPath string) (*JanusAPKInfo, error) {
	info := &JanusAPKInfo{FilePath: apkPath}

	// Try to use apksigner first
	cmd := exec.Command("apksigner", "verify", "-v", apkPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		// Fallback to manual signature checking
		return a.analyzeAPKManually(apkPath)
	}

	// Parse apksigner output
	info.HasV1Signature, info.HasV2Signature, info.HasV3Signature = a.parseApksignerOutput(string(output))

	// Determine vulnerability status
	a.assessVulnerability(info)

	return info, nil
}

func (a *JanusVulnerabilityAnalyzer) analyzeAPKManually(apkPath string) (*JanusAPKInfo, error) {
	info := &JanusAPKInfo{FilePath: apkPath}

	reader, err := zip.OpenReader(apkPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open APK: %v", err)
	}
	defer reader.Close()

	// Check for V1 signatures in META-INF
	for _, file := range reader.File {
		if strings.HasPrefix(file.Name, "META-INF/") &&
			(strings.HasSuffix(file.Name, ".RSA") ||
				strings.HasSuffix(file.Name, ".DSA") ||
				strings.HasSuffix(file.Name, ".EC")) {
			info.HasV1Signature = true
			break
		}
	}

	// For manual analysis, we can't easily detect V2/V3 signatures
	// This is a limitation, but we can still check for V1-only vulnerability
	a.assessVulnerability(info)

	return info, nil
}

func (a *JanusVulnerabilityAnalyzer) parseApksignerOutput(output string) (v1, v2, v3 bool) {
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		switch {
		case strings.HasPrefix(line, "Verified using v1 scheme"):
			v1 = strings.Contains(line, "true")
		case strings.HasPrefix(line, "Verified using v2 scheme"):
			v2 = strings.Contains(line, "true")
		case strings.HasPrefix(line, "Verified using v3 scheme"):
			v3 = strings.Contains(line, "true")
		}
	}
	return
}

func (a *JanusVulnerabilityAnalyzer) assessVulnerability(info *JanusAPKInfo) {
	if !info.HasV1Signature {
		info.Vulnerability = "Not Vulnerable"
		info.Severity = "None"
		info.Description = "APK has no V1 signature and is not vulnerable to Janus attack"
		return
	}

	if info.HasV2Signature || info.HasV3Signature {
		info.Vulnerability = "Potentially Vulnerable"
		info.Severity = "Medium"
		info.Description = "APK has V1 + V2/V3 signatures - vulnerable only on older Android versions"
	} else {
		info.Vulnerability = "Highly Vulnerable"
		info.Severity = "High"
		info.Description = "APK has only V1 signature - vulnerable on Android versions below 7.0"
	}
}

func (a *JanusVulnerabilityAnalyzer) generateFindings(info *JanusAPKInfo) []string {
	var findings []string

	// Add header
	findings = append(findings, fmt.Sprintf(`
%s╭───────────────────────────────────────────────╮
│           Janus Vulnerability Analysis          │
╰───────────────────────────────────────────────╯%s
`, utils.ColorCyan, utils.ColorEnd))

	// Add signature information
	findings = append(findings, fmt.Sprintf(`
%s╭─ Signature Analysis ─%s
│
│  V1 Signature: %s%t%s
│  V2 Signature: %s%t%s
│  V3 Signature: %s%t%s
│
╰────────────────────────────────────────────────`,
		utils.ColorCyan, utils.ColorEnd,
		utils.ColorBlue, info.HasV1Signature, utils.ColorEnd,
		utils.ColorBlue, info.HasV2Signature, utils.ColorEnd,
		utils.ColorBlue, info.HasV3Signature, utils.ColorEnd))

	// Add vulnerability assessment
	severityColor := utils.ColorGreen
	if info.Severity == "Medium" {
		severityColor = utils.ColorYellow
	} else if info.Severity == "High" {
		severityColor = utils.ColorRed
	}

	findings = append(findings, fmt.Sprintf(`
%s╭─ Vulnerability Assessment ─%s
│
│  %s[%s]%s %s
│
│  %s❯ Description:%s
│    %s
│
╰────────────────────────────────────────────────`,
		utils.ColorCyan, utils.ColorEnd,
		severityColor, info.Severity, utils.ColorEnd, info.Vulnerability,
		utils.ColorGreen, utils.ColorEnd, info.Description))

	// Add technical details
	if info.Vulnerability != "Not Vulnerable" {
		findings = append(findings, fmt.Sprintf(`
%s╭─ Technical Details ─%s
│
│  • Janus vulnerability allows malicious apps to inject activities
│  • Attack works by prepending a malicious DEX file to the APK
│  • V1 signature verification only checks the last DEX file
│  • V2/V3 signatures provide better protection against this attack
│
│  %sTesting Recommendations:%s
│  • Test on Android 5.0-6.0 (API 21-23) for V1+V2/V3 signatures
│  • Test on Android 5.0-8.0 (API 21-26) for V1-only signatures
│  • Use 'adb install -r' to replace existing app during testing
│
╰────────────────────────────────────────────────`,
			utils.ColorCyan, utils.ColorEnd,
			utils.ColorYellow, utils.ColorEnd))
	}

	return findings
}

// Helper function to create a minimal DEX file for POC generation
func (a *JanusVulnerabilityAnalyzer) generateMinimalDex() []byte {
	// Create a minimal valid DEX header
	dexHeader := []byte{
		0x64, 0x65, 0x78, 0x0A, 0x30, 0x33, 0x35, 0x00, // DEX_FILE_MAGIC "dex\n035\0"
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // checksum
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // signature
		0x70, 0x00, 0x00, 0x00, // file_size
		0x70, 0x00, 0x00, 0x00, // header_size
		0x78, 0x56, 0x34, 0x12, // endian_tag
		0x00, 0x00, 0x00, 0x00, // link_size
		0x00, 0x00, 0x00, 0x00, // link_off
		0x00, 0x00, 0x00, 0x00, // map_off
		0x01, 0x00, 0x00, 0x00, // string_ids_size
		0x70, 0x00, 0x00, 0x00, // string_ids_off
		0x01, 0x00, 0x00, 0x00, // type_ids_size
		0x78, 0x00, 0x00, 0x00, // type_ids_off
		0x00, 0x00, 0x00, 0x00, // proto_ids_size
		0x00, 0x00, 0x00, 0x00, // proto_ids_off
		0x00, 0x00, 0x00, 0x00, // field_ids_size
		0x00, 0x00, 0x00, 0x00, // field_ids_off
		0x01, 0x00, 0x00, 0x00, // method_ids_size
		0x80, 0x00, 0x00, 0x00, // method_ids_off
		0x01, 0x00, 0x00, 0x00, // class_defs_size
		0x88, 0x00, 0x00, 0x00, // class_defs_off
		0x10, 0x00, 0x00, 0x00, // data_size
		0x90, 0x00, 0x00, 0x00, // data_off
	}
	return dexHeader
}

// Helper function to update DEX checksums
func (a *JanusVulnerabilityAnalyzer) updateDexChecksum(data []byte) error {
	// Update SHA1 signature
	h := sha1.New()
	h.Write(data[32:])
	copy(data[12:32], h.Sum(nil))

	// Update Adler32 checksum
	checksum := adler32.Checksum(data[12:])
	binary.LittleEndian.PutUint32(data[8:12], checksum)

	return nil
}
